#include <algorithm>

#pragma warning(push, 0)
#include <FL/Fl_PNG_Image.H>
#include <FL/fl_draw.H>
#pragma warning(pop)

#include "utils.h"
#include "tile.h"

// 8x8 translucent zigzag pattern for tile priority
static uchar small_priority_png_buffer[] = {
	0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
	0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x02, 0x03, 0x00, 0x00, 0x00, 0xb9, 0x61, 0x56,
	0x18, 0x00, 0x00, 0x00, 0x0c, 0x50, 0x4c, 0x54, 0x45, 0x68, 0xd8, 0xd8, 0x56, 0xba, 0xba, 0x32,
	0x7e, 0x7e, 0x20, 0x60, 0x60, 0xb4, 0x24, 0x6a, 0xe6, 0x00, 0x00, 0x00, 0x04, 0x74, 0x52, 0x4e,
	0x53, 0x60, 0x60, 0x60, 0x60, 0xe8, 0x2d, 0x50, 0x46, 0x00, 0x00, 0x00, 0x16, 0x49, 0x44, 0x41,
	0x54, 0x78, 0x5e, 0x63, 0x90, 0x90, 0x60, 0xa8, 0xab, 0x63, 0x78, 0xfe, 0x9c, 0xa1, 0xb1, 0x11,
	0x99, 0x0d, 0x00, 0x55, 0xe0, 0x07, 0xf9, 0x01, 0x25, 0x72, 0xd2, 0x00, 0x00, 0x00, 0x00, 0x49,
	0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};

static Fl_PNG_Image small_priority_png(NULL, small_priority_png_buffer, sizeof(small_priority_png_buffer));

// 16x16 translucent zigzag pattern for tile priority
static uchar large_priority_png_buffer[] = {
	0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x02, 0x03, 0x00, 0x00, 0x00, 0x62, 0x9d, 0x17,
	0xf2, 0x00, 0x00, 0x00, 0x0c, 0x50, 0x4c, 0x54, 0x45, 0x20, 0x60, 0x60, 0x32, 0x7e, 0x7e, 0x56,
	0xba, 0xba, 0x68, 0xd8, 0xd8, 0xdc, 0xe3, 0x64, 0x6e, 0x00, 0x00, 0x00, 0x04, 0x74, 0x52, 0x4e,
	0x53, 0x60, 0x60, 0x60, 0x60, 0xe8, 0x2d, 0x50, 0x46, 0x00, 0x00, 0x00, 0x2e, 0x49, 0x44, 0x41,
	0x54, 0x78, 0x5e, 0x63, 0xf8, 0x57, 0xff, 0xaf, 0x9e, 0xe1, 0x87, 0xfc, 0x0f, 0x79, 0x86, 0x07,
	0xec, 0x0f, 0xd8, 0x19, 0x1a, 0x18, 0x1b, 0x18, 0x19, 0x80, 0xb8, 0x81, 0x01, 0xc8, 0x7b, 0xc0,
	0x20, 0x0f, 0x94, 0x61, 0x00, 0xaa, 0xf8, 0x47, 0xac, 0x3a, 0x00, 0xfb, 0x8c, 0x1f, 0xe1, 0x3f,
	0x4c, 0xa1, 0xea, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};

static Fl_PNG_Image large_priority_png(NULL, large_priority_png_buffer, sizeof(large_priority_png_buffer));

// 24x24 translucent zigzag pattern for tile priority
static uchar chip_priority_png_buffer[] = {
	0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
	0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 0x02, 0x03, 0x00, 0x00, 0x00, 0x9d, 0x19, 0xd5,
	0x6b, 0x00, 0x00, 0x00, 0x0c, 0x50, 0x4c, 0x54, 0x45, 0x20, 0x60, 0x60, 0x32, 0x7e, 0x7e, 0x56,
	0xba, 0xba, 0x68, 0xd8, 0xd8, 0xdc, 0xe3, 0x64, 0x6e, 0x00, 0x00, 0x00, 0x04, 0x74, 0x52, 0x4e,
	0x53, 0x60, 0x60, 0x60, 0x60, 0xe8, 0x2d, 0x50, 0x46, 0x00, 0x00, 0x00, 0x3d, 0x49, 0x44, 0x41,
	0x54, 0x78, 0x5e, 0xb5, 0xcc, 0xb1, 0x11, 0x80, 0x20, 0x00, 0x04, 0xc1, 0x23, 0xa2, 0x05, 0x33,
	0x3a, 0x15, 0xec, 0x94, 0xcc, 0x16, 0x88, 0x78, 0x6f, 0xe8, 0xc1, 0x99, 0x8d, 0x97, 0xbc, 0x11,
	0x79, 0x22, 0x36, 0x5d, 0x2c, 0x9a, 0x98, 0x54, 0x31, 0x28, 0x82, 0xeb, 0xe0, 0x3e, 0x4a, 0x86,
	0xa8, 0x99, 0xa2, 0x65, 0x89, 0x9e, 0xad, 0x3f, 0xce, 0x0f, 0xcf, 0x49, 0x47, 0xb9, 0xd9, 0x45,
	0x4f, 0x18, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};

static Fl_PNG_Image chip_priority_png(NULL, chip_priority_png_buffer, sizeof(chip_priority_png_buffer));

Tile::Tile(uint8_t id) : _id(id), _palette(Palette::UNDEFINED), _hues(), _rgb() {}

bool Tile::is_blank() const {
	return std::all_of(RANGE(_hues), [](const Hue &h) {
		return h == Hue::WHITE;
	});
}

void Tile::pixel(int x, int y, Hue h, uchar r, uchar g, uchar b) {
	_hues[y * TILE_SIZE + x] = h;
	int i = (y * LINE_BYTES + x * NUM_CHANNELS) * ZOOM_FACTOR;
	// red
	_rgb[i] = r;
	_rgb[i + NUM_CHANNELS] = r;
	_rgb[i + LINE_BYTES] = r;
	_rgb[i + LINE_BYTES + NUM_CHANNELS] = r;
	i++;
	// green
	_rgb[i] = g;
	_rgb[i + NUM_CHANNELS] = g;
	_rgb[i + LINE_BYTES] = g;
	_rgb[i + LINE_BYTES + NUM_CHANNELS] = g;
	i++;
	// blue
	_rgb[i] = b;
	_rgb[i + NUM_CHANNELS] = b;
	_rgb[i + LINE_BYTES] = b;
	_rgb[i + LINE_BYTES + NUM_CHANNELS] = b;
}

void Tile::clear() {
	std::fill_n(_hues, TILE_AREA, Hue::WHITE);
	std::fill_n(_rgb, LINE_PX * LINE_PX * NUM_CHANNELS, (uchar)0xff);
}

void Tile::copy(const Tile *t) {
	_palette = t->_palette;
	memcpy(_hues, t->_hues, TILE_AREA * sizeof(Hue));
	memcpy(_rgb, t->_rgb, LINE_PX * LINE_PX * NUM_CHANNELS);
}

void Tile::update_palettes(Palettes l) {
	for (int ty = 0; ty < TILE_SIZE; ty++) {
		for (int tx = 0; tx < TILE_SIZE; tx++) {
			Hue h = hue(tx, ty);
			const uchar *rgb = Color::color(l, _palette, h);
			pixel(tx, ty, h, rgb[0], rgb[1], rgb[2]);
		}
	}
}

void Tile::draw_with_priority(int x, int y, int s, bool show_priority) const {
	const uchar *rgb = _rgb;
	show_priority &= priority();
	if (s == CHIP_PX_SIZE) {
		uchar chip[CHIP_PX_SIZE * CHIP_PX_SIZE * NUM_CHANNELS] = {};
		for (int ty = 0; ty < TILE_SIZE; ty++) {
			for (int tx = 0; tx < TILE_SIZE; tx++) {
				int ti = (ty * LINE_BYTES + tx * NUM_CHANNELS) * ZOOM_FACTOR;
				int ci = (ty * CHIP_LINE_BYTES + tx * NUM_CHANNELS) * CHIP_ZOOM_FACTOR;
				for (int c = 0; c < NUM_CHANNELS; c++) {
					uchar v = rgb[ti + c];
					for (int row = 0; row < CHIP_ZOOM_FACTOR; row++) {
						for (int col = 0; col < CHIP_ZOOM_FACTOR; col++) {
							chip[ci + CHIP_LINE_BYTES * row + NUM_CHANNELS * col + c] = v;
						}
					}
				}
			}
		}
		fl_draw_image(chip, x, y, CHIP_PX_SIZE, CHIP_PX_SIZE, NUM_CHANNELS, CHIP_LINE_BYTES);
		if (show_priority) {
			chip_priority_png.draw(x, y, CHIP_PX_SIZE, CHIP_PX_SIZE);
		}
	}
	else if (s == TILE_PX_SIZE) {
		fl_draw_image(rgb, x, y, TILE_PX_SIZE, TILE_PX_SIZE, NUM_CHANNELS, LINE_BYTES);
		if (show_priority) {
			large_priority_png.draw(x, y, TILE_PX_SIZE, TILE_PX_SIZE);
		}
	}
	else {
		fl_draw_image(rgb, x, y, TILE_SIZE, TILE_SIZE, NUM_CHANNELS * ZOOM_FACTOR, LINE_BYTES * ZOOM_FACTOR);
		if (show_priority) {
			small_priority_png.draw(x, y, TILE_SIZE, TILE_SIZE);
		}
	}
}

void Tile::draw_for_clipboard(int x, int y) {
	for (int ty = 0; ty < TILE_SIZE; ty++) {
		for (int tx = 0; tx < TILE_SIZE; tx++) {
			int ti = ty * TILE_SIZE + tx;
			uchar c = Color::hue_mono(_hues[ti]);
			fl_color(c, c, c);
			fl_point(x + tx, y + ty);
		}
	}
}
